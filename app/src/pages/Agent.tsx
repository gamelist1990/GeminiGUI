import React, { useState, useRef, useEffect } from "react";
import "./Agent.css";
import "../pages/Chat.css"; // Reuse chat styles
import { ChatMessage, AgentTask, Workspace, ChatSession } from "../types";
import { t, getCurrentLanguage } from "../utils/i18n";
import { callAI, GeminiOptions } from "../utils/geminiCUI";
import { getAllToolNames } from "../AITool/modernTools";
import { scanWorkspace, getSuggestions } from "../utils/workspace";
import * as fsPlugin from "@tauri-apps/plugin-fs";
import ChatMessageBubble from "./Chat/ChatMessageBubble";
import { cleanupManager } from "../utils/cleanupManager";

interface AgentProps {
  workspace: Workspace;
  session: ChatSession;
  sessions: ChatSession[];
  currentSessionId: string;
  maxSessionsReached: boolean;
  approvalMode: 'default' | 'auto_edit' | 'yolo';
  responseMode: 'async' | 'stream';
  totalTokens: number;
  customApiKey?: string;
  googleCloudProjectId?: string;
  maxMessagesBeforeCompact: number;
  globalConfig: any;
  settings: any;
  onCreateNewSession: (isAgentMode?: boolean) => Promise<boolean>;
  onSwitchSession: (sessionId: string) => void;
  onSendMessage: (sessionId: string, message: ChatMessage) => void;
  onResendMessage: (sessionId: string, messageId: string, newMessage: ChatMessage) => void;
  onDeleteSession: (sessionId: string) => void;
  onRenameSession: (sessionId: string, newName: string) => void;
  onCompactSession: (sessionId: string) => void;
  onBack: () => void;
}

export default function Agent({
  workspace,
  session,
  sessions: _sessions,
  currentSessionId,
  maxSessionsReached: _maxSessionsReached,
  approvalMode: _approvalMode,
  responseMode: _responseMode,
  totalTokens,
  customApiKey: _customApiKey,
  googleCloudProjectId: _googleCloudProjectId,
  maxMessagesBeforeCompact: _maxMessagesBeforeCompact,
  globalConfig,
  settings,
  onCreateNewSession: _onCreateNewSession,
  onSwitchSession: _onSwitchSession,
  onSendMessage,
  onResendMessage,
  onDeleteSession: _onDeleteSession,
  onRenameSession: _onRenameSession,
  onCompactSession: _onCompactSession,
  onBack,
}: AgentProps) {
  const [inputValue, setInputValue] = useState("");
  const [tasks, setTasks] = useState<AgentTask[]>([]);
  const [isThinking, setIsThinking] = useState(false);
  const [thinkingMessage, setThinkingMessage] = useState("");
  const [thinkingStartTime, setThinkingStartTime] = useState<number>(0);
  const [currentTaskDescription, setCurrentTaskDescription] = useState("");
  const [elapsedSeconds, setElapsedSeconds] = useState(0);
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const textareaRef = useRef<HTMLTextAreaElement>(null);
  
  // Command and file suggestions state
  const [showCommandSuggestions, setShowCommandSuggestions] = useState(false);
  const [showFileSuggestions, setShowFileSuggestions] = useState(false);
  const [commandSuggestions, setCommandSuggestions] = useState<string[]>([]);
  const [fileSuggestions, setFileSuggestions] = useState<string[]>([]);
  const [workspaceSuggestions, setWorkspaceSuggestions] = useState<string[]>([]);
  const [cursorPosition, setCursorPosition] = useState(0);
  const scanDebounceRef = useRef<NodeJS.Timeout | null>(null);
  
  // Session management state
  const [editingSessionId, setEditingSessionId] = useState<string | null>(null);
  const [editingSessionName, setEditingSessionName] = useState("");
  const [showNewChatDropdown, setShowNewChatDropdown] = useState(false);
  
  const [geminiPath, setGeminiPath] = useState<string | undefined>();

  // Load geminiPath from global config
  useEffect(() => {
    const loadGeminiPath = async () => {
      try {
        const config = await globalConfig.loadConfig();
        const loadedGeminiPath = config?.geminiPath;
        setGeminiPath(loadedGeminiPath);
      } catch (error) {
        console.error("Failed to load geminiPath from global config:", error);
        setGeminiPath(undefined);
      }
    };

    if (globalConfig) {
      loadGeminiPath();
    }
  }, [globalConfig]);

  // Scan workspace for files and folders
  useEffect(() => {
    if (workspace?.path) {
      // Debounce the scan to avoid excessive operations
      if (scanDebounceRef.current) {
        clearTimeout(scanDebounceRef.current);
      }

      scanDebounceRef.current = setTimeout(async () => {
        try {
          const items = await scanWorkspace(workspace.path);
          const suggestions = getSuggestions(items);
          setWorkspaceSuggestions(suggestions);
        } catch (error) {
          console.error("[Agent] Workspace scan failed:", error);
          setWorkspaceSuggestions([]);
        }
      }, 500);
    }

    return () => {
      if (scanDebounceRef.current) {
        clearTimeout(scanDebounceRef.current);
        scanDebounceRef.current = null;
      }
    };
  }, [workspace?.path]);

  // Close dropdown when clicking outside
  useEffect(() => {
    const handleClickOutside = (e: MouseEvent) => {
      const target = e.target as HTMLElement;
      if (!target.closest('.new-chat-dropdown')) {
        setShowNewChatDropdown(false);
      }
    };

    if (showNewChatDropdown) {
      document.addEventListener('mousedown', handleClickOutside);
      return () => document.removeEventListener('mousedown', handleClickOutside);
    }
  }, [showNewChatDropdown]);

  // Scroll to bottom when messages change
  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  }, [session?.messages, tasks]);

  // Update thinking time every second
  useEffect(() => {
    if (!isThinking || thinkingStartTime === 0) {
      setElapsedSeconds(0);
      return;
    }
    
    // Initial calculation
    setElapsedSeconds(Math.floor((Date.now() - thinkingStartTime) / 1000));
    
    const interval = setInterval(() => {
      setElapsedSeconds(Math.floor((Date.now() - thinkingStartTime) / 1000));
    }, 1000);
    
    return () => clearInterval(interval);
  }, [isThinking, thinkingStartTime]);

  // Update suggestions based on input
  useEffect(() => {
    const text = inputValue.substring(0, cursorPosition);
    const lastWord = text.split(/\s/).pop() || "";

    // Command suggestions
    if (lastWord.startsWith("/")) {
      const query = lastWord.substring(1).toLowerCase();
      const commands = ["compact", "improve", "init"];
      const filtered = commands.filter((cmd) => cmd.startsWith(query));
      setCommandSuggestions(filtered);
      setShowCommandSuggestions(filtered.length > 0);
      setShowFileSuggestions(false);
    }
    // File suggestions
    else if (lastWord.startsWith("#")) {
      const query = lastWord.substring(1).toLowerCase();
      const filtered = workspaceSuggestions.filter((suggestion) => {
        const suggestionWithoutHash = suggestion.substring(1).toLowerCase();
        return suggestionWithoutHash.includes(query);
      });
      setFileSuggestions(filtered);
      setShowFileSuggestions(filtered.length > 0);
      setShowCommandSuggestions(false);
    } else {
      setShowCommandSuggestions(false);
      setShowFileSuggestions(false);
    }
  }, [inputValue, cursorPosition, workspaceSuggestions]);

  // Auto-resize textarea
  const handleInputChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    const value = e.target.value;
    setInputValue(value);
    setCursorPosition(e.target.selectionStart || 0);

    // Auto-resize
    const textarea = e.target;
    textarea.style.height = "auto";
    const scrollHeight = textarea.scrollHeight;
    const maxHeight = 200;
    textarea.style.height = `${Math.min(scrollHeight, maxHeight)}px`;
  };

  // Parse task list from AI response
  const parseTasksFromResponse = (content: string): AgentTask[] => {
    const taskRegex = /^[-*]\s*\[([x\s])\]\s*(.+)$/gim;
    const parsedTasks: AgentTask[] = [];
    let match;

    while ((match = taskRegex.exec(content)) !== null) {
      const isCompleted = match[1].toLowerCase() === 'x';
      const description = match[2].trim();
      
      parsedTasks.push({
        id: Date.now().toString() + Math.random(),
        description,
        status: isCompleted ? 'completed' : 'pending',
        createdAt: new Date(),
        updatedAt: new Date(),
      });
    }

    return parsedTasks;
  };

  // Execute autonomous agent loop
  const executeAgentLoop = async (userRequest: string) => {
    setIsThinking(true);
    setThinkingStartTime(Date.now());
    setElapsedSeconds(0);
    setThinkingMessage(t("chat.agent.planningTasks"));
    setCurrentTaskDescription("„Çø„Çπ„ÇØË®àÁîª„Çí‰ΩúÊàê‰∏≠...");

    // Check if OpenAI is enabled - Agent mode requires OpenAI for reliable tool execution
    if (!settings?.enableOpenAI) {
      console.warn('[Agent] OpenAI is not enabled - Agent mode may not work properly with Gemini');
      
      const warningMessage: ChatMessage = {
        id: Date.now().toString(),
        role: 'assistant',
        content: t("chat.agent.openAIWarning"),
        timestamp: new Date(),
      };
      onSendMessage(currentSessionId, warningMessage);
      
      // Add a small delay so user can see the warning
      await new Promise(resolve => setTimeout(resolve, 2000));
    }

    // Store the task plan message ID so we can update it
    const taskPlanMessageId = `task-plan-${Date.now()}`;

    try {
      // Create initial task plan message that will be updated by AI
      const taskListMessage: ChatMessage = {
        id: taskPlanMessageId,
        role: 'assistant',
        content: `üìã **Task Plan Created:**\n\nAnalyzing request and creating task plan...`,
        timestamp: new Date(),
        editable: true,
      };
      onSendMessage(currentSessionId, taskListMessage);

      // Build autonomous agent prompt with tool instructions
      // Get user's language preference
      const userLanguage = getCurrentLanguage();
      const isJapanese = userLanguage === 'ja_JP';
      
      const autonomousPrompt = isJapanese ? 
        `„ÅÇ„Å™„Åü„ÅØËá™ÂæãÂûãAI„Ç®„Éº„Ç∏„Çß„É≥„ÉàÔºà„Ç®„Éº„Ç∏„Çß„É≥„Éà„É¢„Éº„ÉâÔºâ„Åß„Åô„ÄÇ„É¶„Éº„Ç∂„Éº„Åã„Çâ„ÅÆ„É™„ÇØ„Ç®„Çπ„Éà:

"${userRequest}"

**„ÅÇ„Å™„Åü„ÅÆ„Éü„ÉÉ„Ç∑„Éß„É≥:**
„Åì„ÅÆ„Çø„Çπ„ÇØ„ÇíËá™ÂæãÁöÑ„Å´**ÊúÄÂæå„Åæ„ÅßÂÆå‰∫Ü**„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ

**Âà©Áî®ÂèØËÉΩ„Å™„ÉÑ„Éº„É´:**
- **update_task_progress**: „Çø„Çπ„ÇØÈÄ≤Êçó„ÇíÊõ¥Êñ∞Ôºà„Éû„Éº„ÇØ„ÉÄ„Ç¶„É≥„ÉÅ„Çß„ÉÉ„ÇØ„É™„Çπ„Éà: [ ] Êú™ÂÆå‰∫Ü, [x] ÂÆå‰∫ÜÔºâ
- **send_user_message**: ÂÆå‰∫ÜÂ†±ÂëäÔºàtype: "success" „ÅßÂ†±ÂëäÔºâ
- **„Éï„Ç°„Ç§„É´Êìç‰Ωú**: list_directory, read_file, write_file, create_directory „Å™„Å©

**ÈáçË¶Å„Å™ÂäπÁéáÂåñ„É´„Éº„É´:**

1. **„Çø„Çπ„ÇØ„ÅØ3-4ÂÄã„Åæ„Åß** - „Ç∑„É≥„Éó„É´„Å´‰øù„Å§
   ‰æã: ‚ë† ÊÉÖÂ†±ÂèéÈõÜ ‚Üí ‚ë° ÂàÜÊûê„ÉªÂá¶ÁêÜ ‚Üí ‚ë¢ „É¨„Éù„Éº„Éà‰ΩúÊàê ‚Üí ‚ë£ ÂÆå‰∫ÜÂ†±Âëä

2. **‚ö†Ô∏è ÂøÖ„ÅöË§áÊï∞„ÉÑ„Éº„É´„ÇíÂêåÊôÇ„Å´Âëº„Å≥Âá∫„Åô** - „Åì„Çå„ÅåÊúÄ„ÇÇÈáçË¶Å
   ‚ùå ÊÇ™„ÅÑ‰æã: update_task_progress „Å†„ÅëÂëº„Å≥Âá∫„Åô
   ‚úÖ ËâØ„ÅÑ‰æã: update_task_progress + list_directory „ÇíÂêåÊôÇ„Å´Âëº„Å≥Âá∫„Åô

3. **Âêå„Åò„ÉÑ„Éº„É´„ÇíÁπ∞„ÇäËøî„Åï„Å™„ÅÑ** - Â∏∏„Å´ÂâçÈÄ≤„Åô„Çã
   list_directory ‚Üí Ê¨°„ÅØ read_file „ÇÑ write_file

4. **ÊúÄÁü≠„É´„Éº„Éà„ÅßÂÆå‰∫Ü** - ‰∏çË¶Å„Å™„Çπ„ÉÜ„ÉÉ„Éó„Çí„Çπ„Ç≠„ÉÉ„Éó

**„ÉØ„Éº„ÇØ„Éï„É≠„Éº:**

**ÂøúÁ≠î1ÔºàÈñãÂßãÔºâ:**
- update_task_progress(3-4ÂÄã„ÅÆ„Ç∑„É≥„Éó„É´„Å™„Çø„Çπ„ÇØË®àÁîª)
- **ÂêåÊôÇ„Å´** list_directory ÂÆüË°å ‚Üê ÈáçË¶ÅÔºÅ

**ÂøúÁ≠î2-3ÔºàÂÆüË°åÔºâ:**
- update_task_progress(ÂÆå‰∫Ü„Çø„Çπ„ÇØ„Çí [x])
- **ÂêåÊôÇ„Å´** Ê¨°„ÅÆ„ÉÑ„Éº„É´ÂÆüË°åÔºàread_file, write_file „Å™„Å©Ôºâ ‚Üê ÈáçË¶ÅÔºÅ

**ÂøúÁ≠î4ÔºàÂÆå‰∫ÜÔºâ:**
- update_task_progress(ÂÖ®„Çø„Çπ„ÇØ [x])
- **ÂêåÊôÇ„Å´** send_user_message(type: "success", ÂÆå‰∫ÜÂ†±Âëä) ‚Üê ÈáçË¶ÅÔºÅ

**‚ö†Ô∏è Áµ∂ÂØæ„Å´ÂÆà„Çã„Åì„Å®:**
- update_task_progress **„Å†„Åë**„ÇíÂëº„Å≥Âá∫„Åô„ÅÆ„ÅØÁ¶ÅÊ≠¢
- ÊØéÂõû**ÂøÖ„Åö2„Å§‰ª•‰∏ä**„ÅÆ„ÉÑ„Éº„É´„ÇíÂëº„Å≥Âá∫„Åô
- 1„Å§„ÅÆÂøúÁ≠î„ÅßË§áÊï∞„ÉÑ„Éº„É´ = È´òÈÄüÂÆå‰∫Ü

**ÁõÆÊ®ô: 5Âõû‰ª•ÂÜÖ„ÅÆÂøúÁ≠î„ÅßÂÆå‰∫Ü**

‰ªä„Åô„ÅêÈñãÂßã„Åó„Å¶„Åè„Å†„Åï„ÅÑ:
1. 3-4ÂÄã„ÅÆ„Ç∑„É≥„Éó„É´„Å™„Çø„Çπ„ÇØË®àÁîª„Çí‰ΩúÊàê
2. **ÂøÖ„ÅöÂêå„ÅòÂøúÁ≠î„Åß**ÊúÄÂàù„ÅÆ„ÉÑ„Éº„É´„ÇÇÂÆüË°åÔºàlist_directory„Å™„Å©Ôºâ` :
        `You are an autonomous AI agent in Agent Mode. The user has requested:

"${userRequest}"

**Your Mission:**
Complete this task autonomously.

**Available Tools:**
- **update_task_progress**: Update task progress (markdown checklist: [ ] pending, [x] done)
- **send_user_message**: Report completion (type: "success")
- **File operations**: list_directory, read_file, write_file, create_directory, etc.

**Critical Efficiency Rules:**

1. **3-4 tasks maximum** - Keep it simple
   Example: ‚ë† Collect info ‚Üí ‚ë° Analyze/Process ‚Üí ‚ë¢ Create report ‚Üí ‚ë£ Report completion

2. **‚ö†Ô∏è MUST call multiple tools simultaneously** - This is CRITICAL
   ‚ùå Bad: Call update_task_progress only
   ‚úÖ Good: Call update_task_progress + list_directory together

3. **Never repeat the same tool** - Always move forward
   list_directory ‚Üí next use read_file or write_file

4. **Take the shortest path** - Skip unnecessary steps

**Workflow:**

**Response 1 (Start):**
- update_task_progress(3-4 simple task plan)
- **SIMULTANEOUSLY** execute list_directory ‚Üê CRITICAL!

**Response 2-3 (Execute):**
- update_task_progress(mark completed as [x])
- **SIMULTANEOUSLY** execute next tool (read_file, write_file, etc.) ‚Üê CRITICAL!

**Response 4 (Complete):**
- update_task_progress(all tasks [x])
- **SIMULTANEOUSLY** send_user_message(type: "success", completion report) ‚Üê CRITICAL!

**‚ö†Ô∏è ABSOLUTE RULES:**
- Calling update_task_progress **alone** is FORBIDDEN
- MUST call **2+ tools** every time
- Multiple tools per response = fast completion

**Goal: Complete in 5 responses or less**

**Respond in ${isJapanese ? 'Japanese' : 'English'} language**

Start NOW:
1. Create 3-4 simple task plan
2. **MUST execute first tool in same response** (list_directory, etc.)`;

      // Send the autonomous prompt (hidden from user)
      const agentMessage: ChatMessage = {
        id: Date.now().toString(),
        role: 'user',
        content: autonomousPrompt,
        timestamp: new Date(),
        hidden: true,
      };
      onSendMessage(currentSessionId, agentMessage);

      // Track if agent has sent completion message
      let agentCompletionSent = false;
      let latestTaskPlanContent = '';
      
      // Setup Agent tool callbacks
      const agentCallbacks = {
        onUpdateTaskProgress: (markdownContent: string) => {
          console.log('[Agent] Updating task progress:', markdownContent.substring(0, 100));
          
          // Store latest task plan content for completion checking
          latestTaskPlanContent = markdownContent;
          
          // Update the existing task plan message
          const updatedMessage: ChatMessage = {
            id: taskPlanMessageId,
            role: 'assistant',
            content: `üìã **Task Plan:**\n\n${markdownContent}`,
            timestamp: new Date(),
            editable: true,
          };
          // Use resend to update the existing message
          onResendMessage(currentSessionId, taskPlanMessageId, updatedMessage);
          
          // Parse and update tasks in the sidebar
          const parsedTasks = parseTasksFromResponse(markdownContent);
          if (parsedTasks.length > 0) {
            setTasks(parsedTasks);
            
            // Update current task description for thinking indicator
            const currentTask = parsedTasks.find(t => t.status === 'in-progress') || 
                               parsedTasks.find(t => t.status === 'pending');
            if (currentTask) {
              setCurrentTaskDescription(currentTask.description);
            }
          }
        },
        onSendUserMessage: (message: string, messageType: 'info' | 'success' | 'warning' | 'error') => {
          console.log('[Agent] Sending user message:', messageType, message.substring(0, 100));
          
          // Track if agent sent completion message
          if (messageType === 'success') {
            agentCompletionSent = true;
            console.log('[Agent] Completion message received from agent');
          }
          
          const icon = {
            info: '‚ÑπÔ∏è',
            success: 'üéâ',
            warning: '‚ö†Ô∏è',
            error: '‚ùå'
          }[messageType];
          
          const userMessage: ChatMessage = {
            id: Date.now().toString(),
            role: 'assistant',
            content: `${icon} ${messageType === 'success' ? '**„ÄêAll Task Finish„Äë**\n\n' : ''}${message}`,
            timestamp: new Date(),
          };
          onSendMessage(currentSessionId, userMessage);
        }
      };

      // Pass agentCallbacks through settings/options
      // We need to modify the callAI flow to accept agentCallbacks
      // For now, we'll store them globally and access in executeModernTool
      (window as any).__agentCallbacks = agentCallbacks;
      (window as any).__agentSessionId = currentSessionId; // Store session ID for Rust commands

      const baseToolNames = Array.isArray(settings?.enabledTools) && settings.enabledTools.length > 0
        ? settings.enabledTools
        : getAllToolNames();

      const combinedEnabledTools = Array.from(new Set([
        ...baseToolNames,
        'update_task_progress',
        'send_user_message'
      ]));

      const agentOptions: GeminiOptions = {
        approvalMode: 'yolo', // Full autonomy
        includes: ['codebase'],
        enabledTools: [
          ...combinedEnabledTools
        ],
        workspaceId: workspace.id,
        sessionId: currentSessionId,
      };

      // Execute the agent with streaming to see progress
      const agentResponse = await callAI(
        autonomousPrompt,
        workspace.path,
        agentOptions,
        {
          ...settings,
          ...globalConfig,
          responseMode: 'stream'
        },
        (chunk: any) => {
          // Update thinking message with chunk
          if (chunk && chunk.type === 'text' && chunk.content) {
            const text = String(chunk.content);
            setThinkingMessage(text.substring(0, 100) + (text.length > 100 ? '...' : ''));
          }
        }
      );

      // Clear agent callbacks
      delete (window as any).__agentCallbacks;

      console.log('[Agent] Agent execution completed. Completion sent:', agentCompletionSent);
      
      // If agent has not sent completion message, check if we need to continue
      if (!agentCompletionSent) {
        // Parse tasks from the latest task plan to check completion status
        const currentTasks = parseTasksFromResponse(latestTaskPlanContent);
        
        const hasIncompleteTasks = currentTasks.some(
          task => task.status === 'pending' || task.status === 'in-progress'
        );
        
        console.log('[Agent] Task status check:', {
          totalTasks: currentTasks.length,
          hasIncomplete: hasIncompleteTasks,
          taskStatuses: currentTasks.map(t => ({ desc: t.description, status: t.status }))
        });

        // If there are incomplete tasks, prompt AI to continue
        if (hasIncompleteTasks && currentTasks.length > 0) {
          console.log('[Agent] Tasks are not complete, prompting AI to continue...');
          
          const userLanguage = getCurrentLanguage();
          const isJapanese = userLanguage === 'ja_JP';
          
          // Track conversation history locally for the continuation loop
          const localConversationHistory: Array<{ role: string; content: string }> = [];
          
          // Initialize with current session messages
          // Use _sessions to get the most up-to-date session (especially after resend)
          const currentSession = _sessions.find(s => s.id === currentSessionId);
          if (currentSession?.messages) {
            currentSession.messages.forEach(msg => {
              localConversationHistory.push({
                role: msg.role,
                content: msg.content
              });
            });
            console.log(`[Agent] Initial conversation history: ${localConversationHistory.length} messages (from _sessions)`);
          } else if (session?.messages) {
            // Fallback to session prop if _sessions lookup fails
            session.messages.forEach(msg => {
              localConversationHistory.push({
                role: msg.role,
                content: msg.content
              });
            });
            console.log(`[Agent] Initial conversation history: ${localConversationHistory.length} messages (from session prop)`);
          }
          
          console.log(`[Agent] Starting with ${localConversationHistory.length} messages in history`);
          
          // Restore agent callbacks for continuation
          (window as any).__agentCallbacks = {
            onUpdateTaskProgress: (markdownContent: string) => {
              latestTaskPlanContent = markdownContent;
              agentCallbacks.onUpdateTaskProgress(markdownContent);
            },
            onSendUserMessage: (message: string, messageType: 'info' | 'success' | 'warning' | 'error') => {
              if (messageType === 'success') {
                agentCompletionSent = true;
              }
              agentCallbacks.onSendUserMessage(message, messageType);
            }
          };
          (window as any).__agentSessionId = currentSessionId;
          
          // Continue execution - set max iterations to prevent infinite loops
          const maxContinuations = 10; // Reduced from 20 to 10 for efficiency
          let continuationCount = 0;
          
          while (!agentCompletionSent && continuationCount < maxContinuations) {
            continuationCount++;
            console.log(`[Agent] Continuation attempt ${continuationCount}/${maxContinuations}`);
            
            // Re-parse current tasks to get latest status
            const currentIterationTasks = parseTasksFromResponse(latestTaskPlanContent);
            const incompleteTasks = currentIterationTasks.filter(t => t.status === 'pending' || t.status === 'in-progress');
            const completedTasks = currentIterationTasks.filter(t => t.status === 'completed');
            
            console.log(`[Agent] Progress: ${completedTasks.length}/${currentIterationTasks.length} tasks completed`);
            
            // Check if all tasks are now complete
            if (incompleteTasks.length === 0 && currentIterationTasks.length > 0) {
              console.log('[Agent] All tasks completed!');
              if (!agentCompletionSent) {
                // Force send completion message
                const completionMessage: ChatMessage = {
                  id: Date.now().toString(),
                  role: 'assistant',
                  content: `üéâ **„ÄêAll Task Finish„Äë**\n\n„Åô„Åπ„Å¶„ÅÆ„Çø„Çπ„ÇØ„ÅåÊ≠£Â∏∏„Å´ÂÆå‰∫Ü„Åó„Åæ„Åó„ÅüÔºÅ`,
                  timestamp: new Date(),
                };
                onSendMessage(currentSessionId, completionMessage);
              }
              break;
            }
            
            // Update thinking indicator with current progress
            if (incompleteTasks.length > 0) {
              setCurrentTaskDescription(incompleteTasks[0].description);
            }
            
            // Build more specific continuation prompt based on progress
            const specificPrompt = isJapanese ?
              `**ÈÄ≤Êçó: ${completedTasks.length}/${currentIterationTasks.length} ÂÆå‰∫Ü (${Math.round(completedTasks.length / currentIterationTasks.length * 100)}%)**

${incompleteTasks.length > 0 ? `
**Ê¨°„ÅÆ„Çø„Çπ„ÇØ:** ${incompleteTasks[0].description}

**ÂøÖÈ†à„Ç¢„ÇØ„Ç∑„Éß„É≥Ôºà‰∏°ÊñπÂÆüË°åÔºâ:**
${completedTasks.length === 0 ?
  '1Ô∏è‚É£ update_task_progress(„Çø„Çπ„ÇØË®àÁîª)\n2Ô∏è‚É£ list_directory „Åæ„Åü„ÅØ search_files „Åß„Éá„Éº„ÇøÂèéÈõÜÈñãÂßã' :
  completedTasks.length === 1 ? 
  '1Ô∏è‚É£ update_task_progress(„Çø„Çπ„ÇØ1 [x])\n2Ô∏è‚É£ **read_file „Åæ„Åü„ÅØ write_file**Ôºàlist_directoryÁπ∞„ÇäËøî„ÅóÁ¶ÅÊ≠¢Ôºâ\n\n‚ö†Ô∏è ÈáçË¶Å: update_task_progress „Å†„Åë„Åß„Å™„Åè„ÄÅ**ÂÆüÈöõ„ÅÆ‰ΩúÊ•≠„ÉÑ„Éº„É´„ÇÇÂëº„Å≥Âá∫„Åô**' :
  completedTasks.length === 2 ?
  '1Ô∏è‚É£ update_task_progress(„Çø„Çπ„ÇØ2 [x])\n2Ô∏è‚É£ **write_file(`report.md`, ÂÜÖÂÆπ)**\n\n‚ö†Ô∏è **‰ªä„Åô„Åê write_file ÂøÖÈ†à** - „É¨„Éù„Éº„Éà„Çí‰ΩúÊàê„Åó„Å™„ÅÑ„Å®Â§±Êïó' :
  '1Ô∏è‚É£ update_task_progress(ÂÖ® [x])\n2Ô∏è‚É£ send_user_message(type: "success")'
}

**‚ö†Ô∏è Ë≠¶Âëä:**
- update_task_progress **„Å†„Åë**Âëº„Å≥Âá∫„Åô„ÅÆ„ÅØ ‚ùå ‰∏çÂçÅÂàÜ
- ÂøÖ„Åö**2„Å§„ÅÆ„ÉÑ„Éº„É´**„ÇíÂëº„Å≥Âá∫„Åô: update_task_progress + ÂÆüÈöõ„ÅÆ‰ΩúÊ•≠„ÉÑ„Éº„É´

**‰ªä„Åô„ÅêÂÆüË°å:** 2„Å§„ÅÆ„ÉÑ„Éº„É´Âëº„Å≥Âá∫„Åó` : 
  'üéâ ÂÆå‰∫Ü! send_user_message(type: "success")'
}` :
              `**Progress: ${completedTasks.length}/${currentIterationTasks.length} done (${Math.round(completedTasks.length / currentIterationTasks.length * 100)}%)**

${incompleteTasks.length > 0 ? `
**Next Task:** ${incompleteTasks[0].description}

**REQUIRED Actions (execute BOTH):**
${completedTasks.length === 0 ?
  '1Ô∏è‚É£ update_task_progress(task plan)\n2Ô∏è‚É£ list_directory or search_files to start collecting data' :
  completedTasks.length === 1 ? 
  '1Ô∏è‚É£ update_task_progress(Task 1 [x])\n2Ô∏è‚É£ **read_file or write_file** (NO list_directory repeat)\n\n‚ö†Ô∏è Critical: Call **actual work tool**, not just update_task_progress' :
  completedTasks.length === 2 ?
  '1Ô∏è‚É£ update_task_progress(Task 2 [x])\n2Ô∏è‚É£ **write_file(`report.md`, content)**\n\n‚ö†Ô∏è **write_file MANDATORY NOW** - failure to create report = failure' :
  '1Ô∏è‚É£ update_task_progress(all [x])\n2Ô∏è‚É£ send_user_message(type: "success")'
}

**‚ö†Ô∏è WARNING:**
- Calling update_task_progress **only** = ‚ùå INSUFFICIENT
- MUST call **2 tools**: update_task_progress + actual work tool

**Execute NOW:** 2 tool calls` :
  'üéâ Done! send_user_message(type: "success")'
}`;
            
            // Send the continuation prompt (hidden from user, but saved in session)
            const continuationMessage: ChatMessage = {
              id: `continuation-${Date.now()}`,
              role: 'user',
              content: specificPrompt,
              timestamp: new Date(),
              hidden: true, // Hidden from UI but saved in session
            };
            onSendMessage(currentSessionId, continuationMessage);
            
            // Add to local history
            localConversationHistory.push({
              role: 'user',
              content: specificPrompt
            });
            
            // Compress conversation history if it gets too long
            // Keep only: initial user request, latest 10 messages, and current prompt
            let compressedHistory = localConversationHistory;
            if (localConversationHistory.length > 15) {
              compressedHistory = [
                localConversationHistory[0], // Original user request
                ...localConversationHistory.slice(-14) // Latest 14 messages + current prompt
              ];
              console.log(`[Agent] Compressed history: ${localConversationHistory.length} -> ${compressedHistory.length} messages`);
            }
            
            console.log(`[Agent] Building continuation with ${compressedHistory.length} history messages`);
            
            const continuationOptions: GeminiOptions = {
              approvalMode: 'yolo',
              includes: ['codebase'],
              enabledTools: combinedEnabledTools,
              workspaceId: workspace.id,
              sessionId: currentSessionId,
              conversationHistoryJson: compressedHistory, // Pass compressed conversation history
            };
            
            const continuationResponse = await callAI(
              specificPrompt,
              workspace.path,
              continuationOptions,
              {
                ...settings,
                ...globalConfig,
                responseMode: 'stream'
              },
              (chunk: any) => {
                if (chunk && chunk.type === 'text' && chunk.content) {
                  const text = String(chunk.content);
                  setThinkingMessage(text.substring(0, 100) + (text.length > 100 ? '...' : ''));
                }
              }
            );
            
            // Save AI response to session (if it has content) and add to local history
            if (continuationResponse.response && continuationResponse.response.trim()) {
              const responseContent = continuationResponse.response.trim();
              
              // Add to local history
              localConversationHistory.push({
                role: 'assistant',
                content: responseContent
              });
              
              // Only save to session if it's not tool metadata
              if (!responseContent.startsWith('[TOOL]') && !responseContent.includes('[TOOL]')) {
                const responseMessage: ChatMessage = {
                  id: `response-${Date.now()}`,
                  role: 'assistant',
                  content: responseContent,
                  timestamp: new Date(),
                  hidden: true, // Hidden from UI but saved for history
                };
                onSendMessage(currentSessionId, responseMessage);
              }
            }
            
            // Check if completion was sent
            if (agentCompletionSent) {
              console.log('[Agent] Completion confirmed after continuation');
              break;
            }
            
            // Add a delay before next iteration
            await new Promise(resolve => setTimeout(resolve, 2000)); // Increased to 2 seconds
          }
          
          if (continuationCount >= maxContinuations) {
            console.warn('[Agent] Max continuation attempts reached');
            
            // Check if any tasks were actually completed
            const finalTasks = parseTasksFromResponse(latestTaskPlanContent);
            const completedCount = finalTasks.filter(t => t.status === 'completed').length;
            
            const warningMessage: ChatMessage = {
              id: Date.now().toString(),
              role: 'assistant',
              content: `‚ö†Ô∏è „Ç®„Éº„Ç∏„Çß„É≥„Éà„ÅåÊúÄÂ§ßË©¶Ë°åÂõûÊï∞Ôºà${maxContinuations}ÂõûÔºâ„Å´ÈÅî„Åó„Åæ„Åó„Åü„ÄÇ\n\n` +
                      `ÈÄ≤Êçó: ${completedCount}/${finalTasks.length} „Çø„Çπ„ÇØÂÆå‰∫Ü\n\n` +
                      (completedCount > 0 ? 
                        `‰∏ÄÈÉ®„ÅÆ„Çø„Çπ„ÇØ„ÅØÂÆå‰∫Ü„Åó„Åæ„Åó„Åü„Åå„ÄÅ„Åô„Åπ„Å¶„ÅÆ„Çø„Çπ„ÇØ„ÇíÂÆå‰∫Ü„Åß„Åç„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ„Çà„ÇäÂçòÁ¥î„Å™„Çø„Çπ„ÇØ„Å´ÂàÜÂâ≤„Åô„Çã„Åã„ÄÅÊâãÂãï„ÅßÁ∂öË°å„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ` :
                        `„Çø„Çπ„ÇØ„ÅÆÂÆüË°å„Å´ÂïèÈ°å„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇ„Çø„Çπ„ÇØ„Çí„Çà„ÇäÊòéÁ¢∫„Å´„Åô„Çã„Åã„ÄÅÊâãÂãï„ÅßÂÆüË°å„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ`),
              timestamp: new Date(),
            };
            onSendMessage(currentSessionId, warningMessage);
          }
          
          // Clear agent callbacks after all continuations
          delete (window as any).__agentCallbacks;
          delete (window as any).__agentSessionId;
        } else if (currentTasks.length === 0) {
          // No tasks were created - this might be a simple query that doesn't need task decomposition
          console.log('[Agent] No tasks were created, treating as simple query');
          if (agentResponse.response && agentResponse.response.trim()) {
            const responseText = agentResponse.response.trim();
            // Only show if it's not tool metadata
            if (!responseText.startsWith('[TOOL]') && !responseText.includes('[TOOL]')) {
              const infoMessage: ChatMessage = {
                id: Date.now().toString(),
                role: 'assistant',
                content: agentResponse.response,
                timestamp: new Date(),
                editable: true,
                stats: agentResponse.stats,
              };
              onSendMessage(currentSessionId, infoMessage);
            }
          }
        } else {
          // All tasks completed but agent didn't send completion message
          console.log('[Agent] All tasks completed, sending completion message');
          const completionMessage: ChatMessage = {
            id: Date.now().toString(),
            role: 'assistant',
            content: `üéâ **„ÄêAll Task Finish„Äë**\n\n„Åô„Åπ„Å¶„ÅÆ„Çø„Çπ„ÇØ„ÅåÊ≠£Â∏∏„Å´ÂÆå‰∫Ü„Åó„Åæ„Åó„ÅüÔºÅ`,
            timestamp: new Date(),
          };
          onSendMessage(currentSessionId, completionMessage);
        }
      } else {
        console.log('[Agent] Agent sent completion message - tasks finished');
      }

    } catch (error: any) {
      console.error('[Agent] Execution failed:', error);
      
      const errorMessage: ChatMessage = {
        id: Date.now().toString(),
        role: 'assistant',
        content: `‚ùå Agent execution encountered an error: ${error.message || 'Unknown error'}`,
        timestamp: new Date(),
      };
      onSendMessage(currentSessionId, errorMessage);
    } finally {
      setIsThinking(false);
      setThinkingMessage("");
      setThinkingStartTime(0);
      setElapsedSeconds(0);
      setCurrentTaskDescription("");
      // Clear agent callbacks and session ID if still set
      delete (window as any).__agentCallbacks;
      delete (window as any).__agentSessionId;
    }
  };

  // Process commands (similar to regular chat)
  const processCommand = async (command: string, args: string) => {
    if (command === "compact") {
      // Simply delegate to the compact session handler
      try {
        await _onCompactSession(currentSessionId);
        
        // Cleanup tools after compact
        try {
          await cleanupManager.cleanupSession(currentSessionId, workspace.id);
          console.log(`[Agent] Cleaned up tools after /compact`);
        } catch (cleanupError) {
          console.warn('[Agent] Failed to cleanup after /compact:', cleanupError);
        }

        const successMessage: ChatMessage = {
          id: Date.now().toString(),
          role: "assistant",
          content: t("chat.errors.compactCompleted"),
          timestamp: new Date(),
        };
        onSendMessage(currentSessionId, successMessage);
      } catch (error) {
        console.error("[Agent] Error compacting conversation:", error);
        const errorMessage: ChatMessage = {
          id: Date.now().toString(),
          role: "assistant",
          content: t("chat.errors.compactCommandFailed").replace(
            "{error}",
            error instanceof Error ? error.message : "Unknown error"
          ),
          timestamp: new Date(),
        };
        onSendMessage(currentSessionId, errorMessage);
      }
    } else if (command === "init") {
      setIsThinking(true);
      setThinkingMessage(t("chat.errors.initGenerating"));

      try {
        const geminiFilePath = `${workspace.path}/Gemini.md`;
        const hadExistingGemini = await fsPlugin.exists(geminiFilePath);

        let existingGeminiContent = "";
        if (hadExistingGemini) {
          try {
            existingGeminiContent = await fsPlugin.readTextFile(geminiFilePath);
          } catch (readError) {
            console.warn("[Agent] Failed to read existing Gemini.md:", readError);
          }
        }

        const basePrompt = `You are a project analyzer. Analyze this workspace comprehensively and deliver a detailed Gemini.md file.\n\n## Workspace Exploration\n- Use the available tools (for example, glob and read_file) to inspect directories and gather the information you need.\n- Verify important files and configuration by actually reading them.\n\n## Documentation Requirements\nProvide a complete analysis covering:\n\n### Project Overview\n- Project name and purpose\n- Technology stack and frameworks used\n- Target platform and environment\n\n### Architecture & Structure\n- Overall architecture and design patterns\n- Key components and their responsibilities\n- File organization and directory structure\n- Configuration files and their purposes\n\n### Features & Functionality\n- Complete list of implemented features\n- Available APIs and their usage\n- User interface components and workflows\n- Data models and storage solutions\n\n### Technical Details\n- Build system and deployment process\n- Dependencies and external libraries\n- Development tools and scripts\n- Security considerations and authentication\n\n### Code Quality & Standards\n- Coding conventions and style guidelines\n- Testing approach and coverage\n- Documentation standards\n- Performance considerations and optimisations\n\n### Development Workflow\n- Setup and installation instructions\n- Development environment requirements\n- Build and run commands\n- Contribution guidelines\n\n## Output Expectations\n- Return the full Gemini.md content in Markdown.\n- Ensure the result can replace the Gemini.md file entirely.\n- Highlight anything the next developer or AI assistant must know to work effectively.`;

        const normalizedExistingContent = existingGeminiContent
          .replace(/\r/g, "")
          .trim();
        let initPrompt = "";

        if (hadExistingGemini) {
          initPrompt = `${basePrompt}\n\nAn existing Gemini.md file is already present. Review the current content enclosed between <current_gemini_md> markers, then update it to reflect the latest project state. Preserve useful insights, expand missing sections, and correct any outdated information. Produce a full replacement for Gemini.md.\n\n<current_gemini_md>\n${normalizedExistingContent || "(The file is currently empty.)"}\n</current_gemini_md>`;
        } else {
          initPrompt = `${basePrompt}\n\nNo Gemini.md file exists yet. Explore the workspace with the available tools and create a comprehensive Gemini.md from scratch.`;
        }

        const initResponse = await callAI(
          initPrompt,
          workspace.path,
          {
            approvalMode: "yolo",
            model: "gemini-2.5-flash",
            customApiKey: _customApiKey,
            includeDirectories: ["."],
            enabledTools: settings.enabledTools && settings.enabledTools.length > 0 ? settings.enabledTools : undefined,
            workspaceId: workspace.id,
            sessionId: currentSessionId,
          },
          {
            enableOpenAI: settings.enableOpenAI,
            openAIApiKey: settings.openAIApiKey,
            openAIBaseURL: settings.openAIBaseURL,
            openAIModel: settings.openAIModel,
            responseMode: "async",
            googleCloudProjectId: _googleCloudProjectId,
            geminiPath: geminiPath,
          }
        );

        setIsThinking(false);
        
        // Cleanup tools after init
        try {
          await cleanupManager.cleanupSession(currentSessionId, workspace.id);
          console.log(`[Agent] Cleaned up tools after /init`);
        } catch (cleanupError) {
          console.warn('[Agent] Failed to cleanup after /init:', cleanupError);
        }

        const fileExists = await fsPlugin.exists(geminiFilePath);
        const fileStats = initResponse.stats?.files;
        const hasFileChanges = fileStats
          ? fileStats.totalLinesAdded > 0 || fileStats.totalLinesRemoved > 0
          : false;

        if (fileExists && hasFileChanges) {
          const successMessage: ChatMessage = {
            id: Date.now().toString(),
            role: "system",
            content: hadExistingGemini
              ? `‚úÖ Gemini.md„ÇíÊõ¥Êñ∞„Åó„Åæ„Åó„Åü„ÄÇ#file:Gemini.md`
              : `‚úÖ Gemini.md„ÅåÊ≠£Â∏∏„Å´‰ΩúÊàê„Åï„Çå„Åæ„Åó„Åü„ÄÇ#file:Gemini.md`,
            timestamp: new Date(),
          };
          onSendMessage(currentSessionId, successMessage);
        } else {
          const errorMessage: ChatMessage = {
            id: Date.now().toString(),
            role: "assistant",
            content: t("chat.errors.initFailed"),
            timestamp: new Date(),
          };
          onSendMessage(currentSessionId, errorMessage);
        }
      } catch (error) {
        setIsThinking(false);
        console.error("[Agent] Error creating Gemini.md:", error);

        const errorMessage: ChatMessage = {
          id: Date.now().toString(),
          role: "assistant",
          content: t("chat.errors.initFailedWithError").replace(
            "{error}",
            error instanceof Error ? error.message : "Unknown error"
          ),
          timestamp: new Date(),
        };
        onSendMessage(currentSessionId, errorMessage);
      }
    } else if (command === "improve") {
      if (!args.trim()) {
        const errorMessage: ChatMessage = {
          id: Date.now().toString(),
          role: "assistant",
          content: t("chat.errors.improveNoText"),
          timestamp: new Date(),
        };
        onSendMessage(currentSessionId, errorMessage);
        return;
      }

      setIsThinking(true);
      setThinkingMessage(t("chat.errors.improveProcessing"));

      try {
        const improvementPrompt = `„ÅÇ„Å™„Åü„ÅØ„Éó„É≠„É≥„Éó„Éà„Ç®„É≥„Ç∏„Éã„Ç¢„É™„É≥„Ç∞„ÅÆÂ∞ÇÈñÄÂÆ∂„Åß„Åô„ÄÇ‰ª•‰∏ã„ÅÆ„É¶„Éº„Ç∂„Éº„É°„ÉÉ„Çª„Éº„Ç∏„Çí„ÄÅAI„ÅåÁêÜËß£„Åó„ÇÑ„Åô„Åè„ÄÅ„Çà„ÇäÂÖ∑‰ΩìÁöÑ„ÅßÈ´òÂìÅË≥™„Å™Ë°®Áèæ„Å´ÊîπÂñÑ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ

# ÊîπÂñÑ„ÅÆÊåáÈáù
1. **ÊòéÁ¢∫ÊÄß**: ÊõñÊòß„Å™Ë°®Áèæ„ÇíÂÖ∑‰ΩìÁöÑ„Å´„Åô„Çã
2. **ÊßãÈÄ†Âåñ**: Ë§áÈõë„Å™Ë¶ÅÊ±Ç„ÅØÁÆáÊù°Êõ∏„Åç„ÇÑ„Çª„ÇØ„Ç∑„Éß„É≥ÂàÜ„Åë„Åô„Çã
3. **ÊñáËÑà**: ÂøÖË¶Å„Å™ËÉåÊôØÊÉÖÂ†±„ÇíËøΩÂä†„Åô„Çã
4. **ÁõÆÁöÑ**: ‰Ωï„ÇíÈÅîÊàê„Åó„Åü„ÅÑ„ÅÆ„ÅãÊòéÁ¢∫„Å´„Åô„Çã
5. **Âà∂Á¥Ñ**: ÈáçË¶Å„Å™Âà∂Á¥ÑÊù°‰ª∂„Åå„ÅÇ„Çå„Å∞ÊòéÁ§∫„Åô„Çã
6. **Âá∫ÂäõÂΩ¢Âºè**: ÊúüÂæÖ„Åô„ÇãÂõûÁ≠î„ÅÆÂΩ¢Âºè„ÇíÊåáÂÆö„Åô„Çã
7. **‰æãÁ§∫**: ÂøÖË¶Å„Å´Âøú„Åò„Å¶ÂÖ∑‰Ωì‰æã„ÇíËøΩÂä†„Åô„Çã

# ÊîπÂñÑ‰æã
ÊÇ™„ÅÑ‰æã: „Äå„Åì„ÅÆ„Ç≥„Éº„ÉâË™¨Êòé„Åó„Å¶„Äç
ËâØ„ÅÑ‰æã: „Äå‰ª•‰∏ã„ÅÆTypeScript„Ç≥„Éº„Éâ„Å´„Å§„ÅÑ„Å¶„ÄÅÊ©üËÉΩ„ÄÅ‰ΩøÁî®„Åï„Çå„Å¶„ÅÑ„Çã„Éá„Ç∂„Ç§„É≥„Éë„Çø„Éº„É≥„ÄÅÊΩúÂú®ÁöÑ„Å™ÂïèÈ°åÁÇπ„ÇíË™¨Êòé„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇÁâπ„Å´„Ç®„É©„Éº„Éè„É≥„Éâ„É™„É≥„Ç∞„Å®„Éë„Éï„Ç©„Éº„Éû„É≥„Çπ„ÅÆË¶≥ÁÇπ„Åã„ÇâÂàÜÊûê„Çí„ÅäÈ°ò„ÅÑ„Åó„Åæ„Åô„ÄÇ„Äç

# ÂÖÉ„ÅÆ„É°„ÉÉ„Çª„Éº„Ç∏
${args}

# ÊîπÂñÑÂæå„ÅÆ„É°„ÉÉ„Çª„Éº„Ç∏
ÊîπÂñÑ„Åó„Åü„É°„ÉÉ„Çª„Éº„Ç∏„ÅÆ„Åø„ÇíÂá∫Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇË™¨Êòé„ÇÑÂâçÁΩÆ„Åç„ÅØ‰∏çË¶Å„Åß„Åô:`;

        const improvedResponse = await callAI(
          improvementPrompt,
          workspace.path,
          {
            approvalMode: "yolo",
            model: "gemini-2.5-flash",
            customApiKey: _customApiKey,
            enabledTools: settings.enabledTools && settings.enabledTools.length > 0 ? settings.enabledTools : undefined,
            workspaceId: workspace.id,
            sessionId: currentSessionId,
          },
          {
            enableOpenAI: settings.enableOpenAI,
            openAIApiKey: settings.openAIApiKey,
            openAIBaseURL: settings.openAIBaseURL,
            openAIModel: settings.openAIModel,
            responseMode: "async",
            googleCloudProjectId: _googleCloudProjectId,
            geminiPath: geminiPath,
          }
        );

        setIsThinking(false);
        
        // Cleanup tools after improve
        try {
          await cleanupManager.cleanupSession(currentSessionId, workspace.id);
          console.log(`[Agent] Cleaned up tools after /improve`);
        } catch (cleanupError) {
          console.warn('[Agent] Failed to cleanup after /improve:', cleanupError);
        }

        const improvedText = improvedResponse.response.trim();
        setInputValue(improvedText);

        // Focus and adjust textarea height
        setTimeout(() => {
          if (textareaRef.current) {
            const textarea = textareaRef.current;
            textarea.focus();
            textarea.style.height = "auto";
            const scrollHeight = textarea.scrollHeight;
            textarea.style.height = `${Math.min(scrollHeight, 200)}px`;
            textarea.setSelectionRange(improvedText.length, improvedText.length);
          }
        }, 100);
      } catch (error) {
        setIsThinking(false);
        console.error("[Agent] Error improving message:", error);

        const errorMessage: ChatMessage = {
          id: Date.now().toString(),
          role: "assistant",
          content: t("chat.errors.improveCommandFailed").replace(
            "{error}",
            error instanceof Error ? error.message : "Unknown error"
          ),
          timestamp: new Date(),
        };
        onSendMessage(currentSessionId, errorMessage);
      }
    } else if (command === "clear") {
      // Note: Clear command just shows a message for now
      // Full clear functionality would require session reset which is complex
      const clearMessage: ChatMessage = {
        id: Date.now().toString(),
        role: "assistant",
        content: t("chat.errors.clearNotImplemented"),
        timestamp: new Date(),
      };
      onSendMessage(currentSessionId, clearMessage);
    } else if (command === "help") {
      const helpMessage: ChatMessage = {
        id: Date.now().toString(),
        role: "assistant",
        content: `ü§ñ **Agent „Ç≥„Éû„É≥„Éâ„Éò„É´„Éó**

**Âà©Áî®ÂèØËÉΩ„Å™„Ç≥„Éû„É≥„Éâ:**
‚Ä¢ \`/compact\` - ‰ºöË©±Â±•Ê≠¥„ÇíË¶ÅÁ¥Ñ„Åó„Å¶ÂúßÁ∏ÆÔºà„Éà„Éº„ÇØ„É≥ÁØÄÁ¥ÑÔºâ
‚Ä¢ \`/clear\` - „ÉÅ„É£„ÉÉ„Éà„Çí„ÇØ„É™„Ç¢Ôºà„Ç∑„Çπ„ÉÜ„É†„É°„ÉÉ„Çª„Éº„Ç∏„ÅØ‰øùÊåÅÔºâ
‚Ä¢ \`/help\` - „Åì„ÅÆ„Éò„É´„Éó„ÇíË°®Á§∫
‚Ä¢ \`/init\` - „ÉØ„Éº„ÇØ„Çπ„Éö„Éº„Çπ„ÅÆGemini.md„ÇíÁîüÊàê/Êõ¥Êñ∞
‚Ä¢ \`/improve\` - „É°„ÉÉ„Çª„Éº„Ç∏„ÇíÊîπÂñÑ„Åó„Å¶ÂÖ•ÂäõÊ¨Ñ„Å´„Çª„ÉÉ„Éà

**Agent „ÅÆÁâπÂæ¥:**
‚Ä¢ Ëá™Âãï„Çø„Çπ„ÇØÂÆüË°å - „É¶„Éº„Ç∂„Éº„ÅÆ„É™„ÇØ„Ç®„Çπ„Éà„ÇíËá™ÂæãÁöÑ„Å´Âá¶ÁêÜ
‚Ä¢ „ÉÑ„Éº„É´‰ΩøÁî® - „Éï„Ç°„Ç§„É´Êìç‰Ωú„ÄÅ„Ç≥„Éº„ÉâÂÆüË°å„Å™„Å©„ÅÆ„ÉÑ„Éº„É´„ÇíÊ¥ªÁî®
‚Ä¢ „Çø„Çπ„ÇØÁÆ°ÁêÜ - Ë§áÈõë„Å™‰ΩúÊ•≠„ÇíÂ∞è„Åï„Å™„Çπ„ÉÜ„ÉÉ„Éó„Å´ÂàÜËß£

ÈÄöÂ∏∏„ÅÆ„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÈÄÅ‰ø°„Åô„Çã„Å®„ÄÅAgent „ÅåËá™ÂãïÁöÑ„Å´„Çø„Çπ„ÇØ„ÇíÂàÜÊûê„Åó„Å¶ÂÆüË°å„Åó„Åæ„Åô„ÄÇ`,
        timestamp: new Date(),
      };
      onSendMessage(currentSessionId, helpMessage);
    } else {
      const unknownCommandMessage: ChatMessage = {
        id: Date.now().toString(),
        role: "assistant",
        content: `‚ùì Êú™Áü•„ÅÆ„Ç≥„Éû„É≥„Éâ: \`/${command}\`

Âà©Áî®ÂèØËÉΩ„Å™„Ç≥„Éû„É≥„Éâ„ÇíÁ¢∫Ë™ç„Åô„Çã„Å´„ÅØ \`/help\` „Å®ÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ`,
        timestamp: new Date(),
      };
      onSendMessage(currentSessionId, unknownCommandMessage);
    }
  };

  const handleSendMessage = () => {
    if (!inputValue.trim() || isThinking) return;

    // Check if it's a command
    const trimmedInput = inputValue.trim();
    if (trimmedInput.startsWith("/") || trimmedInput.startsWith("#")) {
      const parts = trimmedInput.substring(1).split(" ");
      const command = parts[0];
      const args = parts.slice(1).join(" ");

      processCommand(command, args);
      setInputValue("");
      return;
    }

    const userMessage: ChatMessage = {
      id: Date.now().toString(),
      role: 'user',
      content: inputValue.trim(),
      timestamp: new Date(),
      tokenUsage: Math.ceil(inputValue.trim().length / 4),
    };

    onSendMessage(currentSessionId, userMessage);
    setInputValue("");

    // Reset textarea height
    if (textareaRef.current) {
      textareaRef.current.style.height = "auto";
    }

    // Start autonomous execution
    executeAgentLoop(inputValue.trim());
  };

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && e.ctrlKey) {
      e.preventDefault();
      handleSendMessage();
    }
    // Handle suggestion selection with Enter/Tab
    if ((e.key === 'Enter' || e.key === 'Tab') && (showCommandSuggestions || showFileSuggestions)) {
      e.preventDefault();
      const suggestions = showCommandSuggestions ? commandSuggestions : fileSuggestions;
      if (suggestions.length > 0) {
        const suggestion = showCommandSuggestions ? suggestions[0] : fileSuggestions[0];
        handleSelectSuggestion(suggestion, showCommandSuggestions ? "command" : "file");
      }
    }
  };

  // Handle suggestion selection
  const handleSelectSuggestion = (suggestion: string, type: "command" | "file") => {
    if (!textareaRef.current) return;

    const text = inputValue.substring(0, cursorPosition);
    const lastWordStart = text.lastIndexOf(type === "command" ? "/" : "#");

    if (lastWordStart !== -1) {
      const before = inputValue.substring(0, lastWordStart);
      const after = inputValue.substring(cursorPosition);
      
      // For commands, add the / prefix. For files, suggestion already has # prefix
      const completeSuggestion = type === "command" ? `/${suggestion}` : suggestion;
      const newValue = before + completeSuggestion + " " + after;

      setInputValue(newValue);
      setShowCommandSuggestions(false);
      setShowFileSuggestions(false);

      // Set cursor position after the inserted suggestion
      setTimeout(() => {
        const newCursorPos = lastWordStart + completeSuggestion.length + 1; // +1 for space
        textareaRef.current?.setSelectionRange(newCursorPos, newCursorPos);
        textareaRef.current?.focus();
      }, 0);
    }
  };

  // Session management functions
  const handleRenameSession = (sessionId: string, currentName: string) => {
    setEditingSessionId(sessionId);
    setEditingSessionName(currentName);
  };

  const handleSaveRename = (sessionId: string) => {
    if (editingSessionName.trim()) {
      _onRenameSession(sessionId, editingSessionName.trim());
    }
    setEditingSessionId(null);
    setEditingSessionName("");
  };

  const handleCancelRename = () => {
    setEditingSessionId(null);
    setEditingSessionName("");
  };

  const handleDeleteSession = (sessionId: string) => {
    if (window.confirm(t("chat.sessionDeleteConfirm"))) {
      _onDeleteSession(sessionId);
    }
  };

  // Handle creating a new agent chat session
  const handleNewAgentChat = async () => {
    const success = await _onCreateNewSession(true);
    if (!success) {
      alert(t("chat.sessionLimit"));
    }
    setShowNewChatDropdown(false);
  };

  // Handle creating a new regular chat session
  const handleNewChat = async () => {
    const success = await _onCreateNewSession(false);
    if (!success) {
      alert(t("chat.sessionLimit"));
    }
    setShowNewChatDropdown(false);
  };

  const toggleNewChatDropdown = () => {
    setShowNewChatDropdown(!showNewChatDropdown);
  };

  return (
    <div className="agent-page">
      <div className="agent-header">
        <div className="agent-header-left">
          <button className="back-button secondary" onClick={onBack}>
            ‚Üê {t("workspace.title")}
          </button>
          <div className="agent-badge">
            ü§ñ {t("chat.agent.title")}
          </div>
          <h2 style={{ margin: 0, fontSize: '16px' }}>
            {workspace.name}
          </h2>
        </div>
        <div className="chat-stats">
          <div className="stat">
            <span className="stat-label">{t("chat.tokenUsage")}</span>
            <span className="stat-value">{totalTokens.toLocaleString()}</span>
          </div>
        </div>
        <div className="new-chat-dropdown">
          <div className="new-chat-button-group">
            <button
              className="new-chat-main-button primary"
              onClick={handleNewAgentChat}
              disabled={_maxSessionsReached}
            >
              ‚ú® {t("chat.newChat")}
            </button>
            <button
              className="new-chat-dropdown-toggle primary"
              onClick={toggleNewChatDropdown}
              disabled={_maxSessionsReached}
              title={t("chat.newChatOptions")}
            >
              ‚ñº
            </button>
          </div>
          {showNewChatDropdown && !_maxSessionsReached && (
            <div className="new-chat-dropdown-menu">
              <button className="new-chat-dropdown-item" onClick={handleNewChat}>
                <div className="new-chat-dropdown-item-icon">üí¨</div>
                <div className="new-chat-dropdown-item-content">
                  <div className="new-chat-dropdown-item-title">{t("chat.newChat")}</div>
                  <div className="new-chat-dropdown-item-description">Standard chat mode</div>
                </div>
              </button>
              <button className="new-chat-dropdown-item agent" onClick={handleNewAgentChat}>
                <div className="new-chat-dropdown-item-icon">ü§ñ</div>
                <div className="new-chat-dropdown-item-content">
                  <div className="new-chat-dropdown-item-title">{t("chat.newAgentChat")}</div>
                  <div className="new-chat-dropdown-item-description">{t("chat.agent.description")}</div>
                </div>
              </button>
            </div>
          )}
        </div>
      </div>

      <div className="agent-container">
        <div className="agent-sidebar-sessions">
          <div className="sessions-header">
            <h3>{t("chat.sessions")}</h3>
            <span className="session-count">{_sessions.length}/5</span>
          </div>
          <div className="sessions-list">
            {_sessions.map((session) => (
              <div
                key={session.id}
                className={`session-item ${
                  session.id === currentSessionId ? "active" : ""
                }`}
                onClick={() => _onSwitchSession(session.id)}
              >
                <div className="session-info">
                  {editingSessionId === session.id ? (
                    <input
                      type="text"
                      className="session-name-input"
                      value={editingSessionName}
                      onChange={(e) => setEditingSessionName(e.target.value)}
                      onKeyDown={(e) => {
                        if (e.key === "Enter") {
                          handleSaveRename(session.id);
                        } else if (e.key === "Escape") {
                          handleCancelRename();
                        }
                        e.stopPropagation();
                      }}
                      onClick={(e) => e.stopPropagation()}
                      onBlur={() => handleSaveRename(session.id)}
                      autoFocus
                    />
                  ) : (
                    <span
                      className="session-name"
                      onDoubleClick={(e) => {
                        e.stopPropagation();
                        handleRenameSession(session.id, session.name);
                      }}
                      title="Double-click to rename"
                    >
                      {session.name}
                    </span>
                  )}
                  {isThinking && session.id === currentSessionId && (
                    <div className="request-timer">
                      <div className="timer-spinner"></div>
                      <span className="timer-text">Thinking...</span>
                    </div>
                  )}
                </div>
                <div className="session-actions">
                  <button
                    className="session-action-button delete"
                    onClick={(e) => {
                      e.stopPropagation();
                      handleDeleteSession(session.id);
                    }}
                    title={t("chat.sessionDelete")}
                  >
                    üóëÔ∏è
                  </button>
                </div>
              </div>
            ))}
          </div>
        </div>
        <div className="agent-main">
          <div className="chat-messages">
            {session?.messages
              .filter(msg => !msg.hidden)
              .map((message) => (
                <ChatMessageBubble
                  key={message.id}
                  message={message}
                  workspace={workspace}
                  onResendMessage={message.role === 'user' ? async (newMessage) => {
                    console.log('[Agent] Resending message, clearing state...');
                    
                    // Clear tasks and assistant messages before re-executing
                    setTasks([]);
                    
                    // Clear thinking state
                    setIsThinking(false);
                    setThinkingStartTime(0);
                    setElapsedSeconds(0);
                    setCurrentTaskDescription("");
                    
                    // Call resend to update the session history
                    // This will trim all messages after the resent message
                    onResendMessage(currentSessionId, message.id, newMessage);
                    
                    // Wait for session state to update
                    await new Promise(resolve => setTimeout(resolve, 200));
                    
                    console.log('[Agent] Re-executing agent loop after resend...');
                    
                    // If it's a user message, re-execute the agent loop
                    // The loop will build a fresh conversation history from the trimmed session
                    if (newMessage.role === 'user' && newMessage.content.trim()) {
                      await executeAgentLoop(newMessage.content.trim());
                    }
                  } : undefined}
                />
              ))}

            {isThinking && (
              <div className="agent-thinking-indicator">
                <div className="agent-thinking-spinner"></div>
                <div className="agent-thinking-content">
                  <div className="agent-thinking-task">
                    {currentTaskDescription || t("chat.agent.thinking")}
                  </div>
                  <div className="agent-thinking-stats">
                    <span className="agent-thinking-progress">
                      {tasks.filter(t => t.status === 'completed').length}/{tasks.length} „Çø„Çπ„ÇØÂÆå‰∫Ü
                    </span>
                    {thinkingStartTime > 0 && (
                      <span className="agent-thinking-time">
                        {elapsedSeconds}ÁßíÁµåÈÅé
                      </span>
                    )}
                  </div>
                </div>
              </div>
            )}

            <div ref={messagesEndRef} />
          </div>

          <div className="input-container">
            {(showCommandSuggestions || showFileSuggestions) && (
              <div className="suggestions-popup">
                {showCommandSuggestions &&
                  commandSuggestions.map((cmd) => (
                    <div
                      key={cmd}
                      className="suggestion-item"
                      data-type="command"
                      onClick={() => handleSelectSuggestion(cmd, "command")}
                    >
                      /{cmd}
                    </div>
                  ))}
                {showFileSuggestions &&
                  fileSuggestions.map((file) => (
                    <div
                      key={file}
                      className="suggestion-item"
                      data-type={file === "codebase" ? "codebase" : "file"}
                      onClick={() => handleSelectSuggestion(file, "file")}
                    >
                      {file}
                    </div>
                  ))}
              </div>
            )}
            <textarea
              ref={textareaRef}
              className="chat-input"
              value={inputValue}
              onChange={handleInputChange}
              onKeyDown={handleKeyDown}
              placeholder={t("chat.placeholder")}
              rows={1}
              disabled={isThinking}
            />
            <button
              className="send-button primary"
              onClick={handleSendMessage}
              disabled={!inputValue.trim() || isThinking}
            >
              ‚û§
            </button>
          </div>
        </div>

        <div className="agent-sidebar">
          <div className="agent-tasks-header">
            <h3>üìã {t("chat.agent.tasks")}</h3>
          </div>
          <div className="agent-tasks-list">
            {tasks.length === 0 ? (
              <div className="agent-no-tasks">
                {t("chat.agent.noTasks")}
              </div>
            ) : (
              tasks.map((task) => (
                <div
                  key={task.id}
                  className={`agent-task-item ${task.status}`}
                >
                  <div className={`agent-task-status ${task.status}`}>
                    {task.status === 'pending' && t("chat.agent.taskPending")}
                    {task.status === 'in-progress' && t("chat.agent.taskInProgress")}
                    {task.status === 'completed' && t("chat.agent.taskCompleted")}
                    {task.status === 'failed' && t("chat.agent.taskFailed")}
                  </div>
                  <div className="agent-task-description">
                    {task.description}
                  </div>
                  {task.result && (
                    <div className="agent-task-result">
                      {task.result}
                    </div>
                  )}
                  <div className="agent-task-time">
                    {new Date(task.updatedAt).toLocaleTimeString()}
                  </div>
                </div>
              ))
            )}
          </div>
        </div>
      </div>
    </div>
  );
}
